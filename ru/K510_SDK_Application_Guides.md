![](../zh/images/canaan-cover.png)

**<font face="黑体" size="6" style="float:right">Руководство по применению K510 SDK</font>**

<font face="黑体"  size=3>Версия документа: V1.0.0</font>

<font face="黑体"  size=3>Опубликовано: 2022-03-09</font>

<div style="page-break-after:always"></div>

<font face="黑体" size=3>**Отказ**</font>
Продукты, услуги или функции, которые вы покупаете, регулируются коммерческими контрактами и условиями Beijing Canaan Jiesi Information Technology Co., Ltd. («Компания», то же самое далее), и все или часть продуктов, услуг или функций, описанных в этом документе, могут не входить в сферу вашей покупки или использования. Если иное не оговорено в договоре, Компания отказывается от всех заявлений или гарантий, явных или подразумеваемых, в отношении точности, надежности, полноты, маркетинга, конкретной цели и ненападения любых заявлений, информации или содержания этого документа. Если не согласовано иное, настоящий документ предоставляется только в качестве руководства для использования.
В связи с обновлением версии продукта или по другим причинам содержимое этого документа может время от времени обновляться или изменяться без какого-либо уведомления.

**<font face="黑体"  size=3>Уведомления о товарных знаках</font>**

""<img src="../zh/images/canaan-logo.png" style="zoom:33%;" />, значок "Canaan", Canaan и другие товарные знаки Canaan и другие товарные знаки Canaan являются товарными знаками Beijing Canaan Jiesi Information Technology Co., Ltd. Все другие товарные знаки или зарегистрированные товарные знаки, которые могут быть упомянуты в этом документе, принадлежат их соответствующим владельцам.

**<font face="黑体"  size=3>Copyright ©2022 Пекин Ханаан Цзеси Информационные технологии Co., Ltd</font>**
Настоящий документ применим только к разработке и проектированию платформы K510, без письменного разрешения компании, ни одно подразделение или частное лицо не может распространять часть или все содержание этого документа в любой форме.

**<font face="黑体"  size=3>Пекин Ханаан Цзеси Информационные Технологии Co., Ltd</font>**
URL: canaan-creative.com
Бизнес-запросы: salesAI@canaan-creative.com

<div style="page-break-after:always"></div>
# предисловие
**<font face="黑体"  size=5>Назначение </font>**документа
Этот документ является описанием примера приложения K510 SDK.

**<font face="黑体"  size=5>Объекты чтения</font>**

Основные люди, к которым относится этот документ (это руководство):

- Разработчики программного обеспечения
- Персонал технической поддержки

**<font face="黑体"  size=5>История изменений</font>**
 <font face="宋体"  size=2>Журнал изменений накапливает описание каждого обновления документа. Последняя версия документа содержит обновления для всех предыдущих версий. </font>

| Номер версии | Изменено     | Дата пересмотра   | Примечания к пересмотру     |
| :----- | ---------- | ---------- | ------------ |
| Версия 1.0.0 | Группы системного программного обеспечения | 2022-03-09 | Выпущен пакет SDK версии 1.5 |
|        |            |            |              |
|        |            |            |              |
|        |            |            |              |
|        |            |            |              |
|        |            |            |              |
|        |            |            |              |
|        |            |            |              |
|        |            |            |              |

<div style="page-break-after:always"></div>
**<font face="黑体"  size=6>Содержание</font>**

[ОГЛАВЛЕНИЯ]

<div style="page-break-after:always"></div>

# 1 Демонстрационное приложение

## 1.1 Ai демо-программа

### 1.1.1 Описание

Исходный код демонстрационной программы nncase находится в каталоге под каталогом SDK`package/ai`, а структура каталогов выглядит следующим образом:

```shell
$ tree -L 2 ai
ai
├── ai.hash
├── ai.mk
├── code
│   ├── build.sh
│   ├── cmake
│   ├── CMakeLists.txt
│   ├── common
│   ├── face_alignment
│   ├── face_detect
│   ├── face_expression
│   ├── face_landmarks
│   ├── face_recog
│   ├── hand_image_classify
│   ├── head_pose_estimation
│   ├── imx219_0.conf
│   ├── imx219_1.conf
│   ├── license_plate_recog
│   ├── object_detect
│   ├── object_detect_demo
│   ├── openpose
│   ├── person_detect
│   ├── retinaface_mb_320
│   ├── self_learning
│   ├── shell
│   ├── simple_pose
│   ├── video_192x320.conf
│   ├── video_object_detect_320.conf
│   ├── video_object_detect_320x320.conf
│   ├── video_object_detect_432x368.conf
│   ├── video_object_detect_512.conf
│   ├── video_object_detect_640.conf
│   └── video_object_detect_640x480.conf
└── Config.in
```

Вы можете обратиться к исходному коду retinaface_mb_320 и`CMakeLists.txt` добавить новую демонстрационную программу nncase.

Для компиляции модели см.`nncase_demo.mk` POST_INSTALL_TARGET_HOOKS*, определенные в ней*:

```text
NNCASE_DEMO_DEPENDENCIES += mediactl_lib nncase_linux_runtime opencv4 libdrm
define NNCASE_DEMO_COMPILE_MODEL
    mkdir -p $(TARGET_DIR)/app/ai/kmodel/kmodel_compile/retinaface_mb_320
    cd $(@D) && /usr/bin/python3 retinaface_mb_320/rf_onnx.py --quant_type uint8 --model ai_kmodel_data/model_file/retinaface/retinaface_mobile0.25_320.onnx
    cp $(@D)/rf.kmodel $(TARGET_DIR)/app/ai/kmodel/kmodel_compile/retinaface_mb_320/rf_uint8.kmodel
    cd $(@D) && /usr/bin/python3 retinaface_mb_320/rf_onnx.py --quant_type bf16 --model ai_kmodel_data/model_file/retinaface/retinaface_mobile0.25_320.onnx
    cp $(@D)/rf.kmodel $(TARGET_DIR)/app/ai/kmodel/kmodel_compile/retinaface_mb_320/rf_bf16.kmodel

NNCASE_DEMO_POST_INSTALL_TARGET_HOOKS += NNCASE_DEMO_COMPILE_MODEL
```

Для компиляции модели требуется среда nncase, а для построения среды nncase обратитесь к k510_nncase_Developer_Guides.md. В будущем nncase будет обновлен, и пакет SDK buildroot будет обновляться до nncase синхронно.

### 1.1.2 Сетчатка лица

Функция: распознавание лиц, распознавание лиц

Путь программы:
`/app/ai/shell`
Бежать:
Выполнение неколичественной модели`./retinaface_mb_320_bf16.sh`
Выполните модель квантования uint8,`./retinaface_mb_320_uint8.sh`

В скрипте есть настройки для QOS, такие же, как и для следующих двух демонстраций.

```shell
#devmem phyaddr width value
devmem 0x970E00fc 32 0x0fffff00
devmem 0x970E0100 32 0x000000ff
devmem 0x970E00f4 32 0x00550000
```

При запуске демонстрации необходимо расставить приоритеты, чтобы дисплей экрана был нормальным, то есть настроить QoS, связанный с дисплеем, на высокий приоритет.
QOS_CTRL0.ax25mp запись QoS = 5
QOS_CTRL0.ax25mp чтение QoS = 5
QOS_CTRL2.ispf2k записать QoS = 0xf
QOS_CTRL2.ispf2k читать QoS = 0xf
QOS_CTRL2.ispr2k записать QoS = 0xf
QOS_CTRL2.ispr2k читать QoS = 0xf
QOS_CTRL2.isp3dtof записать QoS = 0xf
QOS_CTRL3.display чтение QoS = 0xf
QOS_CTRL3.display записать QoS = 0xf

Смещение регистра управления QOS 0[QOS_CTRL0](0x00f4)
 ![Qos CTRL0](../zh/images/sdk_application/demo_nncase_qos_ctrl0.png)

Смещение регистра управления QOS 1 [QOS_CTRL1](0x00f8)
 ![QOS CTRL1](../zh/images/sdk_application/demo_nncase_qos_ctrl1.png)

Смещение регистра управления QOS 2 [QOS_CTRL2](0x00fc)
 ![QOS CTRL2](../zh/images/sdk_application/demo_nncase_qos_ctrl2.png)

Смещение регистра управления QOS 3 [QOS_CTRL3](0x0100)
 ![QOS CTRL3](../zh/images/sdk_application/demo_nncase_qos_ctrl3.png)

Компиляция и установка модели подробно описаны в файле package/ai/ai.mk:

Путь к сценарию компиляции:
пакет/ai/код/retinaface_mb_320/rf_onnx.py

### 1.1.3 object_detect

Функция: Обнаружение классификации объектов, классификация 80

Путь программы:`/app/ai/shell`

Бежать:
Выполнение неколичественной модели`./object_detect_demo_bf16.sh`
Выполните модель квантования uint8,`./object_detect_demo_uint8.sh`

Компиляция и установка модели подробно описаны в пакете файлов/ai/ai.mk

Путь к сценарию компиляции:
пакет/ai/код/object_detect_demo/od_onnx.py

## 1.2 ffmpeg

`ffmpeg``ffmpeg-4.4`Портирован на открытый исходный код, добавлен`0001-buildroot-ffmpeg-0.1.patch` для пакетов обновления

- `ff_k510_video_demuxer`: Управляет входом isp, на который ссылается`libvideo.so`
- `ff_libk510_h264_encoder`: Управление аппаратной кодировкой h264, ссылка`libvenc.so`

Настраиваемые параметры можно просмотреть с помощью директивы help

```shell
ffmpeg -h encoder=libk510_h264 #查看k510编码器的参数
ffmpeg -h demuxer=libk510_video #查看demuxer的配置参数
```

Подробные инструкции по запуску см.[в K510_Multimedia_Developer_Guides.md](./K510_Multimedia_Developer_Guides.md)

## 1.3 alsa_demo

Демо-программа alsa размещена в`/app/alsa_demo` каталоге:

Подготовка к запуску:
(1) Подключите наушники

Запустите демонстрацию alsa:

```shell
cd /app/alsa_demo/
./alsa_demo c #录音到文件capture.pcm，demo程序仅作参考，可以参考package/alsa_demo的源码。
./alsa_demo p #播放capture.pcm
```

## 1.4 Демо TWOD

Как запустить вращение:

```shell
cd /app/twod_app
./twod-rotation-app
```

Скопируйте .yuv ouput на монитор YUV и установите размер 1080 x 1920, формат отображения nv12, результат следующий
![выход.yuv](../zh/images/sdk_application/driver-twod-output-1080x1920.jpg)

Использование скейлера

```shell
cd /app/twod_app
./twod-scaler-app
```

Скопируйте .yuv ouput на монитор YUV и установите размер 640x480, формат отображения nv12, результат следующий
![ouput.yuv](../zh/images/sdk_application/driver-twod-output-640x480.jpg)

Как запустить rgb2yuv:

```shell
cd /app/twod_app
./twod-osd2yuv-app
```

Скопируйте .yuv ouput на монитор YUV и установите размер 320x240, формат отображения nv12, результат будет следующим:
![ouput.yuv](../zh/images/sdk_application/twod-osd2yuv-app.jpg)

Запуск yuv2rgb использование:

```shell
cd /app/twod_app
./twod-scaler-output-rgb888-app
```

Скопируйте .yuv ouput на монитор rgb888 и установите размер 640x480, формат отображения rgb24, результат будет следующим:
![ouput.yuv](../zh/images/sdk_application/driver-twod-output-640x480.jpg)

Запустите выходной yuv при использовании osd наложения:

```shell
cd /app/twod_app
./twod-scaler-overlay-osd-app
```

Скопируйте .yuv ouput на монитор, чтобы установить размер 640x480, формат отображения nv12, результат следующий
![ouput.yuv](../zh/images/sdk_application/twod-scaler-overlay-osd-app.jpg)

API:

```c
/* 创建内存 */
twod_create_fb()
/* 配置原图片参数 */   
twod_set_src_picture()
/* 配置输出图片参数 */ 
twod_set_des_picture()
/* 设置 scaler */     
twod_set_scaler()
/* 等待操作完成 */     
twod_wait_vsync()
/* Invali cache */   
twod_InvalidateCache()
/* flash cache */     
twod_flashdateCache()
/* 释放内存*/     
twod_free_mem()
/* 设置旋转 */  
twod_set_rot()
```

## 1.5 Демонстрация RTC

Драйвер RTC регистрирует узел устройства build /dev/rtc0.

Прикладной уровень следует стандартному методу программирования RTC в драйвере системных вызовов Linux, и рекомендуется отключить печать информации о ядре через консоль оболочки перед запуском эталонной процедуры.

```shell
echo 0 > /proc/sys/kernel/printk
```

Перейдите в каталог /app/rtc и введите следующую команду, чтобы запустить приложение rtc.

```shell
cd /app/rtc
./rtc 2021-11-3 21:10:59
```

Результатом выполнения программы является:

![](../zh/images/sdk_application/image-rtc.png)

Основной фрагмент кода демонстрационной программы RTC выглядит следующим образом, пожалуйста, обратитесь к коду в папке package/rtc для получения подробной информации.

```c
/*解析参数，获取当前年月日、时分秒*/
if(argc !=3) {
    fprintf(stdout, "useage:\t ./rtc year-month-day hour:minute:second\n");
    fprintf(stdout, "example: ./rtc 2021-10-11 19:54:30\n");
    return -1;
}

sscanf(argv[1], "%d-%d-%d",  &year, &month, &day);
sscanf(argv[2], "%d:%d:%d",  &hour, &minute, &second);

/*打开RTC设备，设备节点是：/dev/rtc0 */
fd = open("/dev/rtc0", O_RDONLY);
if (fd == -1) {
    perror("/dev/rtc0");
    exit(errno);
}

/* 设置RTC时间。*/
retval = ioctl(fd, RTC_SET_TIME, &rtc_tm);
if (retval == -1) {
    perror("ioctl");
    exit(errno);
}

/* 休眠 2秒。 */
sleep(2);

/* 读取RTC当前时间。*/
retval = ioctl(fd, RTC_RD_TIME, &rtc_tm);
if (retval == -1) {
    perror("ioctl");
    exit(errno);
}

/* 打印 RTC当前时间。*/
fprintf(stdout, "\nRTC date/time: %d/%d/%d %02d:%02d:%02d\n",
        rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,
        rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);
```

## 1.6 Демонстрация WDT

K510 имеет в общей сложности три сторожевых пса, а драйвер WDT регистрирует узлы устройств генерации /dev/watchdog0, /dev/watchdog1, /dev/watchdog2.

Прикладной уровень следует стандартному методу программирования WDT в драйвере системных вызовов Linux, первый параметр приложения wathdog может быть 0, 1, представлять watchdog0, watchdog1, соответственно, второй параметр представляет время ожидания (единицу секунд), которое можно задать, например, следующая команда указывает на запуск watchdog0, время переполнения watchdog0 составляет 40 секунд.

```shell
cd /app/watchdog
./watchdog 0 40
```

После запуска программа будет подавать сторожевой пес каждые 1 секунду с интервалом, когда символ остановки вводится в терминал оболочки, приложение перестает кормить собаку, а сторожевой пес будет сбрасывать перезапуск устройства после переполнения времени ожидания настройки, пожалуйста, обратитесь к коду в папке package/watchdog для получения подробной информации.

Результатом выполнения программы является:

![](../zh/images/sdk_application/image-watchdog.png)

**Примечание**: Текущий сторожевой модуль k510 имеет рабочую тактовую частоту 757575 Гц, а время ожидания в секундах должно быть преобразовано в время ожидания фактической рабочей тактовой частоты сторожевого пса, которое вычисляется как 2^н/757575, поэтому фактическое время ожидания будет больше или равно входному тайм-ауту.

Фактический период ожидания рассчитывается следующим образом:

1) Введите 40, 2^25/757575=44 > 40, 2^24/757575=22 < 40, так что он установлен на 44 секунды;

2) Введите 155, 2^27/757575=177 > 155, так что он установлен на 177 секунд;

3) Введите 2000, 2^31/757575=2834 > 2000, так что он установлен на 2834 секунды;

## 1.7 Демонстрация UART

K510 имеет в общей сложности 4 последовательных порта, текущий драйвер в последовательных портах 2, 3 не включен, драйвер последовательного порта 0 будет зарегистрирован для генерации узлов устройства /dev/ttyS0.

Прикладной уровень следует стандартному методу программирования UART в драйвере системных вызовов Linux. Первым параметром приложения uart может быть 0 и 1, которые представляют uart0 и uart1 соответственно.

Плата разработки использует проводную сеть для подключения к маршрутизатору, так что плата разработки и отладка ПК в сети, когда плата разработки включена, автоматически получит IP-адрес, введет команду ifconfig в последовательный терминал оболочки платы разработки для получения IP-адреса, а отладочный ПК использует этот IP-адрес для открытия окна telent путем подключения платы разработки через telent соединение. Например, операция отладки ПК для подключения платы разработки с помощью telent через MobaXterm показана на следующем рисунке.

![](../zh/images/sdk_application/image-uart-mobaxterm.png)

Введите следующую команду в окне терминала telent, чтобы начать работу последовательного порта 0.

```shell
cd /app/uart
./uart 0
```

Введите содержимое, которое вы хотите отправить в окне telent, вы можете увидеть полученные данные в окне последовательного терминала оболочки, пожалуйста, обратитесь к коду под папкой package/crb_demo/uart для деталей.
Например, входные данные для окна telent:

![](../zh/images/sdk_application/image-uart-telent.png)

В соответствующем окне последовательного терминала оболочки отображается:

![](../zh/images/sdk_application/image-uart-shell.png)

## 1.8 Демо ETH

Прикладной уровень следует стандартному драйверу вызова метода программирования ETH в системах Linux.

### 1.8.1 Клиент

Устройство в качестве клиента, введите каталог /app/client, введите следующую команду для запуска клиентского приложения, первый параметр приложения ETH указывает IP-адрес сервера для установления TCP-связи, например, введите следующую команду для запуска программы ETH и сервер 10.20.1.13 для установления связи.

```shell
cd /app/client
./client 10.20.1.13
```

Подключите сервер для связи по протоколу tcp, запустите серверную программу на другой машине ubuntu, пожалуйста, обратитесь к папке пакета / приложения / клиента для получения подробной информации.

Отображение журналов на стороне устройства:

![](../zh/images/sdk_application/image-client.png)

### 1.8.2 Сервер

Устройство входит в каталог /app/server в качестве сервера, например, введите следующую команду, чтобы запустить серверную программу.

```shell
cd /app/server
./server
```

Запустите клиентскую программу на другой машине ubuntu, подключите сервер через протокол tcp для связи, для получения подробной информации, пожалуйста, обратитесь к папке package/crb_demo/server.

Отображение журналов на стороне устройства:

 ![](../zh/images/sdk_application/image-server.png)

## 1.9 Демонстрация SDMMC

K510 имеет в общей сложности 3 основных контроллера SDMMC, плата разработки SDMMC0 используется для подключения eMMC, SDMMC1 используется для модулей WIFI, а контроллер SDMMC2 используется для подключения sdcard.

Драйвер SDMMC регистрируется для создания /dev/mmcblk0, а драйвер EMMC регистрируется как узел устройства /dev/mmcblk1.

SD-карта будет автоматически смонтирована в /root/data после запуска системы, войдите в каталог /app/write_read_file, первый параметр приложения SDMMC указывает файл для чтения и записи, например SD-карта, смонтированная в /root/data, вы можете читать и записывать файлы в каталоге /root/data/, сначала записывать, а затем читать, Введите следующую команду, чтобы запустить приложение SDMMC для чтения и записи на SD-карту и расчета скорости чтения и записи (единица м/с).

```shell
cd /app/write_read_file
./write_read_file /root/data/test.txt
```

Чтобы включить чтение и запись данных 1G на SD-карту, обратитесь к папке/приложению/write_read_file папке.

![](../zh/images/sdk_application/image-sdmmc.png)

## 1.10 Демонстрация SHA/AES

Демонстрация SHA/AES использует ядро Linux для экспорта AF_ALG тип интерфейса Netlink и использует API шифрования ядра в пользовательском пространстве. Пожалуйста, обратитесь к разделу .<https://www.kernel.org/doc/html/latest/crypto/userspace-if.html>

Параметр:
-h Печать справочной информации
-t Тип алгоритма: хэш, скифер
-n Названия алгоритмов: sha256, ecb(aes), cbc(aes)
-x Операция расшифровки
-k AES KEY (шестнадцатеричная строка)
-v AES IV (шестнадцатеричная строка)

![](../zh/images/sdk_application/image_crypto_help.png)

тест sha256:

```shell
cd /app/crypto
echo -n "This is a test file, hello world" > plain.txt
./crypto -t hash -n "sha256" plain.txt sha256.txt
xxd -p -c 32 sha256.txt
sha256sum plain.txt
```

![](../zh/images/sdk_application/image_crypto_sha256.png)

ecb(aes) 128 тест:

```shell
cd /app/crypto
echo -n "This is a test file, hello world" > plain.txt
./crypto -t skcipher -n "ecb(aes)" -k 00112233445566778899aabbccddeeff plain.txt ecb_aes_en.bin
./crypto -t skcipher -n "ecb(aes)" -k 00112233445566778899aabbccddeeff  -x ecb_aes_en.bin ecb_aes_de.bin
cmp ecb_aes_de.bin plain.txt
cat ecb_aes_de.bin
```

![](../zh/images/sdk_application/image_crypto_ecb.png)

cbc(aes) 128 тест

```shell
cd /app/crypto
echo -n "This is a test file, hello world" > plain.txt
./crypto -t skcipher -n "cbc(aes)" -k 00112233445566778899aabbccddeeff -v 00112233445566778899aabbccddeeff plain.txt cbc_aes_en.bin
./crypto -t skcipher -n "cbc(aes)" -k 00112233445566778899aabbccddeeff -v 00112233445566778899aabbccddeeff -x cbc_aes_en.bin cbc_aes_de.bin
cmp cbc_aes_de.bin plain.txt
cat cbc_aes_de.bin
```

![](../zh/images/sdk_application/image_crypto_cbc.png)

Шифрование AES-ECB-128 и aes-cbc-128 требует 16-байтового выравнивания открытого текста, а недостаточное автоматически заполняется 0.

## 1.11 Демо TRNG

Демонстрация TRNG выдает случайное число заданной длины путем считывания символьного устройства /dev/hwrng, выводимого в виде шестнадцатеричной строки.

Значение входного параметра ./trng:

-h Печать справочной информации

-b Задает длину выходного случайного числа в байтах

![](../zh/images/sdk_application/image_trng.png)

## 1.12 Демо DRM

Демонстрация Drm демонстрирует многослойные возможности аппаратного обеспечения vo.

Vo имеет в общей сложности 8 слоев:

1) Фоновый слой, можно настроить цвет фона.

2) Layer0 - это видеослой, поддерживает YUV422 и YUV420, поддерживает форматы NV12 и NV21, может быть сопоставлен на стороне размера и поддерживает аппаратное масштабирование вверх и вниз.

3) Layer1-layer3 - это видеослой, поддерживающий YUV422 и YUV420, поддерживающий форматы NV12 и NV21, и сторона размера может быть сопоставлена.

4) Layer4-layer6 - это слой ЭКРАННОГО МЕНЮ, который поддерживает несколько форматов ARGB.

После запуска платы зайдите в каталог /app/drm_demo и введите команду:

```shell
cd /app/drm_demo
./drm_demo
```

Запустите drm_demo приложение, drm_demo отобразится:

![](../zh/images/sdk_application/image_drm_demo.png)

## 1.13 V4L2_DRM демо

v4l2_drm демонстрация демонстрирует функциональность ввода и отображения камеры.

После запуска платы зайдите в каталог /app/mediactl_lib и введите команду:

```shell
cd /app/mediactl_lib
./v4l2_drm.out -f video_drm_1080x1920.conf -e 1
或者
./v4l2_drm.out -f video_drm_1920x1080.conf
```

Запустите приложение v4l2_drm.out и отобразите v4l2_drm.out:

![](../zh/images/sdk_application/image_v4l2_drm_demo.png)

## 1.14 Демонстрация LVGL

Перейдите в /app/lvgl и выполните следующую команду:

```shell
cd /app/lvgl
./lvgl
```

Эффект отображения выглядит следующим образом:![](../zh/images/sdk_application/image_lvgl.png)

## 1.15 ШИМ демо

Драйвер ШИМ регистрирует узлы устройств генерации /sys/class/pwm/pwmchip0 и /sys/class/pwm/pwmchip3.

Этот пример можно настроить и включить для pwm0 и pwm1 соответственно, в каталоге /app/pwm, первый параметр приложения pwm указывает период установки pwm, блок ns, второй параметр задает время "ON" в цикле pwm, единица измерения ns, третий параметр может быть 0, 1, представляющий pwm0 и pwm1, например, введите следующую команду для включения pwm0, цикл равен 1s, рабочий цикл равен 10000000/ 5000000000*100% = 50%, пожалуйста, обратитесь к папке/app/pwm папке для получения подробных кодов.

```shell
cd /app/pwm
./pwm 1000000000 500000000 0
```

Результатом выполнения программы является:

![](../zh/images/sdk_application/image-pwm.png)

При подключении контакта 28 платы разработки K510 CRB1.2 J15 через осциллограф на осциллографе можно наблюдать форму сигнала с периодом 1 секунда и рабочим циклом 50%.

## 1.16 Демонстрация WIFI

После загрузки драйвера модуля WiFi генерируется беспроводная сетевая карта wlan0, которая следует стандартному драйверу сетевого порта и обычно относится к программированию сокета TCP/IP.

1) Откройте «Мобильную точку доступа» в записной книжке, а затем установите имя и пароль точки доступа
2) Запустите NetAssist на записной книжке, настройте тип протокола, IP-адрес локального хоста, порт локального хоста, параметры приема, параметры отправки и данные, которые необходимо отправить, как показано на следующем рисунке:

    ![](../zh/images/sdk_application/image_wifi_1.png)

3) Формат параметра программы тестирования Wi-Fi:

    ```shell
    ./wifi <AP name> <password> <local ip> <server ip>
    ```

    Например, введите каталог /app/wifi, введите команду для запуска программы тестирования Wi-Fi, и результат выполнения программы будет следующим:

    ![](../zh/images/sdk_application/image_wifi_2.png)

## 1.17 GPIO_KEYS демо

Ключевой драйвер использует само ядро linux, интегрированное с универсальным драйвером gpu-keys на основе входной подсистемы, и после загрузки драйвера узел мониторинга событий eventX генерируется в каталоге /dev/input, а X — порядковый номер узла события, который можно просмотреть через cat /proc/bus/input/devices

gpio-клавиши процедуры блокировки чтения ключевых отчетных событий и печати информации о событиях, ее информация включает в себя кодирование ключа и действие клавиши, код клавиши для идентификации идентичности ключа, действие ключа разделено на нажатое и отпущенное, в выпуске клавиши, когда процедура рассчитает продолжительность нажатия клавиши

Результат выполнения программы показан на следующем рисунке:![](../zh/images/sdk_application/image-gpio-keys.png)

**Отказ от ответственности за**перевод  
Для удобства клиентов Canaan использует переводчик AI для перевода текста на несколько языков, которые могут содержать ошибки. Мы не гарантируем точность, надежность или своевременность предоставленных переводов. Компания Canaan не несет ответственности за любые убытки или ущерб, вызванные доверием к точности или надежности переведенной информации. При наличии разницы в содержании переводов на разные языки преимущественную силу имеет упрощенная версия на китайском языке.

Если вы хотите сообщить об ошибке или неточности перевода, пожалуйста, не стесняйтесь обращаться к нам по почте.
